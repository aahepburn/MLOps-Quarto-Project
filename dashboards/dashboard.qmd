---
title: "Financial Analytics"
format:
  html:
    theme:
      - cosmo
      - master-styles.scss
    page-layout: full
    toc: true
    toc-depth: 3
    embed-resources: false
    df-print: default
    code-fold: false
    include-in-header: []
---

```{python}
#| context: setup
#| echo: false
#| warning: false
import os
import sys
import json
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import warnings

warnings.filterwarnings('ignore', category=FutureWarning)

# Use Quarto execution info to get the document path, so relative data paths are stable
doc_dir = None
info_path = os.environ.get("QUARTO_EXECUTE_INFO")
if info_path and os.path.exists(info_path):
    with open(info_path) as f:
        info = json.load(f)
    doc_dir = os.path.dirname(info["document-path"])
else:
    doc_dir = os.getcwd()

project_root = os.path.dirname(doc_dir)
sys.path.insert(0, project_root)

from src.data.preprocessing import preprocess_data

data_loaded = False
df = None

processed_data_path = os.path.join(project_root, "data", "processed", "train.csv")
raw_data_path = os.path.join(project_root, "data", "raw", "Financials.csv")

if os.path.exists(processed_data_path):
    try:
        df = pd.read_csv(processed_data_path)
        if "Date" in df.columns:
            df["Date"] = pd.to_datetime(df["Date"])
        data_loaded = True
    except Exception as e:
        print(f"Error loading processed: {e}")

if not data_loaded and os.path.exists(raw_data_path):
    try:
        df = preprocess_data(raw_data_path)
        data_loaded = df is not None
    except Exception as e:
        print(f"Error loading raw: {e}")

# Initialize date range variables
date_range_start = "N/A"
date_range_end = "N/A"

if data_loaded:
    df["Year"] = df["Date"].dt.year
    df["Month_Year"] = df["Date"].dt.to_period("M").astype(str)
    date_range_start = df["Date"].min().strftime("%b %Y")
    date_range_end = df["Date"].max().strftime("%b %Y")

SEGMENT_COLORS = {
    "Government": "#2E86AB",
    "Small Business": "#A23B72",
    "Enterprise": "#F18F01",
    "Midmarket": "#C73E1D",
    "Channel Partners": "#6A994E",
}
SALES_COLOR = "#2E86AB"
PROFIT_COLOR = "#6A994E"
```

## Executive Summary

```{python}
#| echo: false
#| output: asis

if data_loaded and df is not None:
    print(f"This dashboard provides a comprehensive view of financial performance across multiple dimensions. The dataset spans {date_range_start} to {date_range_end} and includes {len(df)} transactions across {df['Segment'].nunique()} business segments and {df['Country'].nunique()} geographic regions. The analysis aggregates over ${df['Sales'].sum()/1e6:.1f}M in revenue with a {(df['Profit'].sum()/df['Sales'].sum()*100):.1f}% profit margin, enabling identification of high-performing segments, geographic opportunities, and product-level margin optimization targets.")
else:
    print("Data not available for summary.")
```

### Key Insights

```{python}
#| echo: false
#| output: asis

if data_loaded and df is not None:
    total_sales = df["Sales"].sum()
    total_profit = df["Profit"].sum()
    margin = total_profit / total_sales * 100
    
    top_segment = df.groupby("Segment")["Sales"].sum().idxmax()
    top_segment_value = df.groupby("Segment")["Sales"].sum().max()
    
    top_country = df.groupby("Country")["Sales"].sum().idxmax()
    top_country_value = df.groupby("Country")["Sales"].sum().max()
    
    # Calculate product margins
    prod_margins = df.groupby("Product").agg({
        "Sales": "sum",
        "Profit": "sum"
    }).reset_index()
    prod_margins["Margin"] = prod_margins["Profit"] / prod_margins["Sales"] * 100
    
    lowest_margin_product = prod_margins.loc[prod_margins["Margin"].idxmin(), "Product"]
    highest_margin_product = prod_margins.loc[prod_margins["Margin"].idxmax(), "Product"]
    highest_margin_value = prod_margins["Margin"].max()
    
    insights = [
        f"**Government segment** leads revenue generation at ${top_segment_value/1e6:.1f}M, representing the largest revenue opportunity and strategic focus area.",
        f"**Geographic concentration** shows the best performance in {top_country}, accounting for ${top_country_value/1e6:.1f}M in revenue and indicating potential expansion opportunity. Other markets demonstrate strong sales, too.",
        f"**Product margin** ranges from {lowest_margin_product} at lower profitability to {highest_margin_product} at {highest_margin_value:.1f}%, suggesting targeted margin improvement initiatives.",
        f"**Overall profit margin** of {margin:.1f}% indicates healthy operational efficiency, with potential upside through segment-specific optimization."
    ]
    
    for i, insight in enumerate(insights, 1):
        print(f"{i}. {insight}\n")
else:
    print("Data not loaded – check setup cell paths.")
```

## Overview

### KPIs

```{python}
#| echo: false

if data_loaded and df is not None:
    total_sales   = df["Sales"].sum()
    total_profit  = df["Profit"].sum()
    margin        = total_profit / total_sales * 100
    transactions  = len(df)

    kpi_table = pd.DataFrame({
        "Metric": [
            "Total Revenue",
            "Total Profit",
            "Profit Margin",
            "Transaction Count"
        ],
        "Value": [
            f"${total_sales/1e6:.1f}M",
            f"${total_profit/1e6:.1f}M",
            f"{margin:.1f}%",
            f"{transactions:,}"
        ]
    })
    
    display(kpi_table)
else:
    display("Data not loaded – check setup cell paths.")
```

### Monthly Revenue and Profit

Temporal trend analysis reveals seasonal patterns and growth trajectory. The line chart aggregates monthly revenue and profit across all segments, providing insight into business momentum and profitability consistency over the 10-month observation period.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    monthly = (
        df.sort_values("Date")
          .groupby("Month_Year")
          .agg({"Sales": "sum", "Profit": "sum"})
          .reset_index()
    )

    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=monthly["Month_Year"],
        y=monthly["Sales"],
        name="Revenue",
        line=dict(color=SALES_COLOR, width=3),
        fill="tonexty",
        fillcolor="rgba(46,134,171,0.12)"
    ))
    fig.add_trace(go.Scatter(
        x=monthly["Month_Year"],
        y=monthly["Profit"],
        name="Profit",
        line=dict(color=PROFIT_COLOR, width=3)
    ))

    fig.update_layout(
        title="Monthly Performance Trend",
        height=420,
        xaxis_title="Month",
        yaxis_title="USD",
        hovermode="x unified",
        margin=dict(l=60, r=20, t=60, b=60),
        legend=dict(
            orientation="h",
            yanchor="bottom", y=1.02,
            xanchor="right",  x=1
        ),
        font=dict(size=13)
    )

    display(fig)
else:
    display("Data not loaded – check setup cell paths.")
```

### Revenue by Segment

Segment composition analysis shows the distribution of revenue across business units. Enterprise and Government segments represent the primary revenue drivers, while smaller segments offer targeted growth opportunities.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    seg = (
        df.groupby("Segment", as_index=False)
          .agg({"Sales": "sum", "Profit": "sum"})
    )
    seg["Margin %"] = seg["Profit"] / seg["Sales"] * 100
    seg = seg.sort_values("Sales", ascending=True)

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=seg["Segment"],
        x=seg["Sales"],
        orientation="h",
        marker_color=[SEGMENT_COLORS.get(s, SALES_COLOR) for s in seg["Segment"]],
        text=seg["Sales"].apply(lambda x: f"${x/1e6:.1f}M"),
        textposition="outside",
        hovertemplate=(
            "<b>%{y}</b><br>"
            "Revenue: $%{x:,.0f}<br>"
            "Margin: %{custom:.1f}%<extra></extra>"
        ),
        customdata=seg["Margin %"]
    ))

    fig.update_layout(
        title="Segment Revenue Distribution",
        height=400,
        xaxis_title="Revenue (USD)",
        yaxis_title="",
        margin=dict(l=120, r=20, t=60, b=50),
        showlegend=False,
        font=dict(size=13)
    )

    display(fig)
else:
    display("Data not loaded – check setup cell paths.")
```

## Segments and Regions

Performance across segments and geographic markets provides strategic context for resource allocation and expansion planning.

### Revenue and Margin by Segment

Combined view of absolute revenue and profitability margins by segment. Higher margin segments may indicate operational efficiency or pricing power, while lower-margin segments may represent volume plays or strategic investments.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    seg2 = (
        df.groupby("Segment", as_index=False)
          .agg({"Sales": "sum", "Profit": "sum"})
    )
    seg2["Margin %"] = seg2["Profit"] / seg2["Sales"] * 100

    fig = go.Figure()
    fig.add_trace(go.Bar(
        x=seg2["Segment"],
        y=seg2["Sales"],
        name="Revenue",
        marker_color=SALES_COLOR,
        text=seg2["Sales"].apply(lambda x: f"${x/1e6:.1f}M"),
        textposition="outside"
    ))
    fig.add_trace(go.Scatter(
        x=seg2["Segment"],
        y=seg2["Margin %"],
        name="Margin %",
        yaxis="y2",
        mode="lines+markers",
        line=dict(color=PROFIT_COLOR, width=3),
        marker=dict(size=10)
    ))

    fig.update_layout(
        title="Segment Revenue and Profitability",
        height=420,
        xaxis_title="Segment",
        yaxis_title="Revenue (USD)",
        yaxis2=dict(
            title="Profit Margin (%)",
            overlaying="y",
            side="right",
            showgrid=False
        ),
        margin=dict(l=60, r=60, t=60, b=80),
        legend=dict(
            orientation="h",
            yanchor="bottom", y=1.02,
            xanchor="right",  x=1
        ),
        font=dict(size=13)
    )

    display(fig)
else:
    display("Data not loaded – check setup cell paths.")
```

### Revenue by Country

Geographic performance reveals market penetration and identifies regions for strategic investment or market development initiatives.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    country = (
        df.groupby("Country", as_index=False)
          .agg({"Sales": "sum", "Profit": "sum"})
    )
    country["Margin %"] = country["Profit"] / country["Sales"] * 100
    country = country.sort_values("Sales", ascending=True)

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=country["Country"],
        x=country["Sales"],
        orientation="h",
        marker_color=SALES_COLOR,
        text=country["Sales"].apply(lambda x: f"${x/1e6:.1f}M"),
        textposition="outside",
        hovertemplate=(
            "<b>%{y}</b><br>"
            "Revenue: $%{x:,.0f}<br>"
            "Margin: %{custom:.1f}%<extra></extra>"
        ),
        customdata=country["Margin %"]
    ))

    fig.update_layout(
        title="Geographic Revenue Performance",
        height=400,
        xaxis_title="Revenue (USD)",
        yaxis_title="",
        margin=dict(l=120, r=20, t=60, b=50),
        font=dict(size=13)
    )

    display(fig)
else:
    display("Data not loaded – check setup cell paths.")
```

### Segment and Country Cross-Analysis

Bubble chart analysis enabling simultaneous evaluation of revenue scale, profitability margin, and profit volume across segment and geographic dimensions. Bubble size represents absolute profit contribution.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    cross = (
        df.groupby(["Segment", "Country"], as_index=False)
          .agg({"Sales": "sum", "Profit": "sum"})
    )
    cross["Margin %"] = cross["Profit"] / cross["Sales"] * 100

    fig = px.scatter(
        cross,
        x="Sales",
        y="Margin %",
        size="Profit",
        color="Segment",
        hover_data=["Country"],
        color_discrete_map=SEGMENT_COLORS,
        size_max=50
    )

    fig.update_layout(
        title="Revenue, Margin, and Profit by Segment and Country",
        height=420,
        xaxis_title="Revenue (USD)",
        yaxis_title="Profit Margin (%)",
        margin=dict(l=60, r=20, t=60, b=60),
        legend=dict(
            orientation="h",
            yanchor="bottom", y=-0.28,
            xanchor="center", x=0.5
        ),
        font=dict(size=13)
    )

    fig.update_traces(marker=dict(line=dict(width=1, color="white")))

    display(fig)
else:
    display("Data not loaded – check setup cell paths.")
```

### Performance Summary

Key performance indicators aggregated by segment and country. Identifies top revenue generators, highest-margin segments, and average transaction values for prioritization and strategic planning.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    top_seg = df.groupby("Segment")["Sales"].sum().sort_values(ascending=False)
    top_country = df.groupby("Country")["Sales"].sum().sort_values(ascending=False)

    seg_margin = df.groupby("Segment").agg({"Sales": "sum", "Profit": "sum"})
    seg_margin["Margin"] = seg_margin["Profit"] / seg_margin["Sales"] * 100
    best_margin = seg_margin["Margin"].sort_values(ascending=False)

    summary = pd.DataFrame([
        {
            "Dimension": "Top Revenue Segment",
            "Value": f"{top_seg.index[0]} (${top_seg.iloc[0]/1e6:.1f}M)",
        },
        {
            "Dimension": "Top Revenue Country",
            "Value": f"{top_country.index[0]} (${top_country.iloc[0]/1e6:.1f}M)",
        },
        {
            "Dimension": "Highest Margin Segment",
            "Value": f"{best_margin.index[0]} ({best_margin.iloc[0]:.1f}%)",
        },
        {
            "Dimension": "Mean Transaction Value",
            "Value": f"${df['Sales'].mean():,.0f}",
        },
    ])

    display(summary)
else:
    display("Data not loaded – check setup cell paths.")
```

## Products and Margins

Product-level analysis identifies profitability drivers and margin optimization opportunities across the portfolio.

### Margin Analysis by Product

Product profitability comparison using color-coded visualization to highlight margin stratification. Products are sorted by margin to identify high-efficiency and low-efficiency offerings requiring strategic review.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    prod = (
        df.groupby("Product", as_index=False)
          .agg({"Sales": "sum", "Profit": "sum", "Units Sold": "sum"})
    )
    prod["Margin %"] = prod["Profit"] / prod["Sales"] * 100
    prod = prod.sort_values("Margin %", ascending=True)

    def margin_color(m):
        if m < 40:
            return "#d73027"
        elif m < 50:
            return "#fee08b"
        return "#1a9850"

    colors = [margin_color(m) for m in prod["Margin %"]]

    fig = go.Figure()
    fig.add_trace(go.Bar(
        y=prod["Product"],
        x=prod["Margin %"],
        orientation="h",
        marker_color=colors,
        text=prod["Margin %"].apply(lambda x: f"{x:.1f}%"),
        textposition="outside",
        hovertemplate=(
            "<b>%{y}</b><br>"
            "Margin: %{x:.1f}%<br>"
            "Revenue: $%{custom:,.0f}<extra></extra>"
        ),
        customdata=prod["Sales"]
    ))

    fig.update_layout(
        title="Product Margin Distribution",
        height=420,
        xaxis_title="Profit Margin (%)",
        yaxis_title="Product",
        margin=dict(l=140, r=20, t=60, b=60),
        font=dict(size=13)
    )

    display(fig)
else:
    display("Data not loaded – check setup cell paths.")
```

### Units Sold Distribution

Box plot analysis showing transaction-level unit volumes and distributional characteristics. Identifies outliers and typical order sizes for demand planning and logistics optimization.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    fig = go.Figure()
    fig.add_trace(go.Box(
        y=df["Units Sold"],
        name="",
        marker_color=SALES_COLOR,
        boxmean="sd"
    ))

    fig.update_layout(
        title="Transaction Unit Volume Distribution",
        height=400,
        yaxis_title="Units per Transaction",
        margin=dict(l=60, r=20, t=60, b=50),
        showlegend=False,
        font=dict(size=13)
    )

    display(fig)
else:
    display("Data not loaded – check setup cell paths.")
```

### Product Metrics Summary

Summary statistics for pricing and volume analysis. Enables evaluation of pricing strategy consistency and identification of outlier transactions for further investigation.

```{python}
#| echo: false
#| warning: false

if data_loaded and df is not None:
    stats = pd.DataFrame([
        {"Metric": "Median Units per Transaction", "Value": f"{df['Units Sold'].median():,.0f}"},
        {"Metric": "Mean Sale Price", "Value": f"${df['Sale Price'].mean():,.2f}"},
        {"Metric": "Price Range", "Value": f"${df['Sale Price'].min():.0f} – ${df['Sale Price'].max():.0f}"},
    ])

    display(stats)
else:
    display("Data not loaded – check setup cell paths.")
```
